<!--
@license
(C) Copyright Nuxeo Corp. (http://nuxeo.com/)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<html>
  <head>
    <title>nuxeo-document-suggestion-widgets</title>
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes" />
    <script src="../../../@webcomponents/webcomponentsjs/webcomponents-bundle.js"></script>
    <script src="../../../wct-browser-legacy/browser.js"></script>
    <script src="../../../@nuxeo/nuxeo-elements/dedup.js"></script>
    <script src="../../../@nuxeo/nuxeo-elements/test/test-helpers.js"></script>
  </head>
  <body>
    <test-fixture id="nx">
      <template>
        <nuxeo-connection url="/dummy"></nuxeo-connection>
      </template>
    </test-fixture>

    <test-fixture id="singleSuggestion">
      <template>
        <nuxeo-document-suggestion readonly> </nuxeo-document-suggestion>
      </template>
    </test-fixture>

    <test-fixture id="multiSuggestion">
      <template>
        <nuxeo-document-suggestion readonly multiple> </nuxeo-document-suggestion>
      </template>
    </test-fixture>

    <script type="module">
      import { dom } from '@polymer/polymer/lib/legacy/polymer.dom.js';
      import '@polymer/polymer/polymer-legacy.js';
      import '@polymer/iron-test-helpers/mock-interactions.js';
      import '@nuxeo/nuxeo-elements/nuxeo-connection.js';
      import '@nuxeo/nuxeo-elements/nuxeo-operation.js';
      import { RoutingBehavior } from '../nuxeo-routing-behavior.js';
      import '../widgets/nuxeo-document-suggestion.js';

      // "Mock" Routing Behavior since it needs to be created
      RoutingBehavior.__router = {
        baseUrl: '',
        useHashbang: true,
        browse() {
          return '#';
        },
        user() {
          return '#';
        },
        group() {
          return '#';
        },
      };

      // Return Selectivity Entries
      function getSuggestions(suggestionWidget, timeout = 1000) {
        const s2 = dom(suggestionWidget.root).querySelector('#s2');
        const start = Date.now();
        const waitForLoaded = (resolve, reject) => {
          const result = dom(s2.root).querySelectorAll(
            `.selectivity-${suggestionWidget.multiple ? 'multiple' : 'single'}-selected-item`,
          );
          const timedOut = timeout && Date.now() - start >= timeout;
          if (result && (result.length > 0 || timedOut)) {
            resolve(Array.from(result));
          } else if (timedOut) {
            reject(new Error('Timeout: No suggestions'));
          } else {
            setTimeout(waitForLoaded.bind(this, resolve, reject), 30);
          }
        };
        return new Promise(waitForLoaded);
      }

      suite('Nuxeo Document Suggestion - Widget', () => {
        let suggestionWidget;

        setup(() => {
          const server = sinon.fakeServer.create();
          server.autoRespond = true;
          server.respondWith('POST', '/dummy/api/v1/automation/Document.FetchByProperty', (xhr) => {
            const { params } = JSON.parse(xhr.requestBody);
            const response = {
              'entity-type': 'documents',
              entries: [],
            };

            // Mock response according to request body parameters
            if (params.values === 'existingDocId' || params.values.includes('existingDocId')) {
              response.entries.push({
                'entity-type': 'document',
                facets: ['Folderish', 'NXTag', 'SuperSpace'],
                path: '/default-domain/workspaces/toto',
                repository: 'default',
                state: 'project',
                title: 'Some Title',
                type: 'Workspace',
                uid: 'existingDocId',
              });
            }
            xhr.respond(200, { 'Content-Type': 'application/json' }, JSON.stringify(response));
          });

          // login
          const nx = fixture('nx');
          return login(server, nx);
        });

        suite('Single Suggestion Selection', () => {
          setup(() => {
            suggestionWidget = fixture('singleSuggestion');
            sinon.spy(suggestionWidget, '_resolveDocs');
          });

          test('Should be able to resolve document and display its title', () => {
            suggestionWidget.value = 'existingDocId';
            return flush()
              .then(() => getSuggestions(suggestionWidget))
              .then((entries) => {
                expect(entries.length).to.be.equal(1);
                expect(entries[0].childElementCount).to.be.equal(1);
                expect(entries[0].children[0].nodeName.toLowerCase()).to.be.equal('a');
                expect(entries[0].children[0].textContent).to.be.equal('Some Title');
                expect(suggestionWidget._resolveDocs.calledOnce).to.be.equal(true);
              });
          });

          test('Should not be able to resolve document but display its UID', () => {
            suggestionWidget.value = 'deletedDocId';
            return flush()
              .then(() => getSuggestions(suggestionWidget))
              .then((entries) => {
                expect(entries.length).to.be.equal(1);
                expect(entries[0].childElementCount).to.be.equal(1);
                expect(entries[0].children[0].nodeName.toLowerCase()).to.be.equal('span');
                expect(entries[0].children[0].textContent).to.be.equal('deletedDocId');
                expect(suggestionWidget._resolveDocs.calledOnce).to.be.equal(true);
              });
          });

          test('Should be able to handle empty value', () => {
            suggestionWidget.value = '';
            return flush()
              .then(() => getSuggestions(suggestionWidget))
              .then((entries) => {
                expect(entries.length).to.be.equal(0);
                expect(suggestionWidget._resolveDocs.notCalled).to.be.equal(true);
              });
          });

          test('Should not need to resolve document since it already exists', () => {
            suggestionWidget.value = {
              'entity-type': 'document',
              facets: ['Folderish', 'NXTag', 'SuperSpace'],
              path: '/default-domain/workspaces/toto',
              repository: 'default',
              state: 'project',
              title: 'Some Title',
              type: 'Workspace',
              uid: 'existingDocId',
            };
            return flush()
              .then(() => getSuggestions(suggestionWidget))
              .then((entries) => {
                expect(entries.length).to.be.equal(1);
                expect(entries[0].childElementCount).to.be.equal(1);
                expect(entries[0].children[0].nodeName.toLowerCase()).to.be.equal('a');
                expect(entries[0].children[0].textContent).to.be.equal('Some Title');
                expect(suggestionWidget._resolveDocs.notCalled).to.be.equal(true);
              });
          });
        });

        suite('Multiple Suggestion Selection', () => {
          setup(() => {
            suggestionWidget = fixture('multiSuggestion');
            sinon.spy(suggestionWidget, '_resolveDocs');
          });

          test('Should be able to resolve the existing documents and reconciliate the deleted ones', () => {
            suggestionWidget.value = ['existingDocId', 'deletedDocId'];
            return flush()
              .then(() => getSuggestions(suggestionWidget))
              .then((entries) => {
                expect(entries.length).to.be.equal(2);
                expect(entries[0].childElementCount).to.be.equal(1);
                expect(entries[0].children[0].nodeName.toLowerCase()).to.be.equal('a');
                expect(entries[0].children[0].textContent).to.be.equal('Some Title');

                expect(entries[1].childElementCount).to.be.equal(1);
                expect(entries[1].children[0].nodeName.toLowerCase()).to.be.equal('span');
                expect(entries[1].children[0].textContent).to.be.equal('deletedDocId');

                expect(suggestionWidget._resolveDocs.calledOnce).to.be.equal(true);
              });
          });

          test('Should not need to resolve documents since, at least, one is already resolved', () => {
            suggestionWidget.value = [
              'deletedDocId',
              {
                'entity-type': 'document',
                facets: ['Folderish', 'NXTag', 'SuperSpace'],
                path: '/default-domain/workspaces/toto',
                repository: 'default',
                state: 'project',
                title: 'Some Title',
                type: 'Workspace',
                uid: 'existingDocId',
              },
            ];
            return flush()
              .then(() => getSuggestions(suggestionWidget))
              .then((entries) => {
                expect(entries.length).to.be.equal(2);

                expect(entries[0].childElementCount).to.be.equal(1);
                expect(entries[0].children[0].nodeName.toLowerCase()).to.be.equal('span');
                expect(entries[0].children[0].textContent).to.be.equal('deletedDocId');

                expect(entries[1].childElementCount).to.be.equal(1);
                expect(entries[1].children[0].nodeName.toLowerCase()).to.be.equal('a');
                expect(entries[1].children[0].textContent).to.be.equal('Some Title');

                expect(suggestionWidget._resolveDocs.notCalled).to.be.equal(true);
              });
          });

          test('Should be able to handle empty value', () => {
            suggestionWidget.value = [];
            return flush()
              .then(() => getSuggestions(suggestionWidget))
              .then((entries) => {
                expect(entries.length).to.be.equal(0);
                expect(suggestionWidget._resolveDocs.notCalled).to.be.equal(true);
              });
          });
        });
      });
    </script>
  </body>
</html>
